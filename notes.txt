I would like to replace super-hands with a system that handles interactions.
I want the replacement to make minimal use of aframe, so that we can eventually drop it.
I want the replacement to make minimal use of events, both because of performance reasons and to avoid the additional complexity dealing with the DOM brings to the problem.

The first attempt can be seen in ca515a116928df3d164275684e20244c8abe3ec6 . The problem I encountered in this attempt is in trying to match the three.js object deep within th duck model's hierarchy that the cursor intersects with the aframe element as defined in the `interactable-media` template. This approach feels extremely error prone and confusing, so I want to think of another.

The second attempt can be seen in a9fb0fca8a01414241f51f8e0bd17f824c8bae40 . I "solved" the problem above by grouping all threejs object3D's beneath the one associated with an entity with a given "aggregator" component on it. This works for the simple case of hovering, but I suspect that I will quickly have to change the menu systems such that the menus are not children of the object in order to continue this way. Alternatively I can keep track of which object3D's are associated with a menu and disallow the aggregation of those object3D's when trying to hover on the duck rather than the duck's menu buttons, but this seems complicated and error prone, so I am not sure I want to go down that route. I think the next steps are to start naively implementing some of the features we like that super-hands helps us provide and pay attention to and try to fix any issues that come up as I go along.

I have an unused schema property in this attempt called `offerConstraintWhenHovered`. The thinking here is that I don't want to have a generic "hovering" -- I want the state of the interaction system to be more granular than that. What you're hovering on (rotation button vs volume slider vs duck) and how you're "hovering" (via pointing a cursor at something or intersecting it with your hand) DOES matter to us and to the input system's action sets, so I'd like to model the replacement for "hovering" to respect that. Here the (unimplemented) idea I had is that one kind of hovering will be for changing the action sets to be in a state where creating a physics constraint is a button press away. Thus when you "hover" onto something marked as offerConstraintWhenHovered, well, that's what the thing will do -- you'll end up activating an action set whose associated bindings have a binding written to createPhysicsConstraintOnCursor(/Hand) action path.
